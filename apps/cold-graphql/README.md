<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://cold-public-assets.s3.us-east-2.amazonaws.com/Asset+4Logotype_Preferred.svg" width="699" alt="Cold Climate Logo" /></a>
</p>
<center><img alt="GraphQL_Logo.svg" height="300" src="GraphQL_Logo.svg" width="40"/></center>

# Cold Climate GraphQL API

This is a GraphQL API for cold climate data. It is built with Node.js, Fastify, and Apollo Server.  The Schema & Resolvers are generated dynamically using [Graphweaver](https://graphweaver.com) 

## Getting Started
This repository uses PNPM as the package manager. To install the dependencies, run the following command:

```bash
pnpm install
```

## Generating Schema

The schema is mostly generated by Graphweaver.  Graphweaver requires you store Authorization and Business Logic via decorators stored in each of the generated entities.

When you ask Graphweaver to generate the schema, it will generate `entities` and `schema` folders in `/src/backend` folder of the project.

For example, take a look at the product entity as generated by Graphweaver.  Notice the @ApplyAccessControl and @ApplyHooks decorators are missing.

`entities/Product.ts`
```typescript
@Entity({ tableName: 'products' })
export class Product {
	@PrimaryKey({ type: 'text' })
	id!: string;

	@Unique({ name: 'products_name_key' })
	@Property({ type: 'text' })
	name!: string;

	@Property({ type: 'datetime', length: 3 })
	createdAt!: Date;

	@Property({ type: 'datetime', length: 3 })
	updatedAt!: Date;

	@Property({ type: 'boolean', default: false })
	deleted = false;

	@ManyToOne({ entity: () => Organization, ref: true, index: 'products_organization_id_idx' })
	organization!: Ref<Organization>;

	@OneToMany({ entity: () => OrganizationAttribute, mappedBy: 'product' })
	organizationAttributes = new Collection<OrganizationAttribute>(this);

	@OneToMany({ entity: () => ProductMaterial, mappedBy: 'product' })
	productMaterials = new Collection<ProductMaterial>(this);
}
```

### Adding Authorization to Entities
Now let's add authorization to the entity.  We will add the @ApplyAccessControl decorator to use the `default_acl` (defined in `./backend/acl_policies.ts`) which grants read/write access to `company:owner` and `company:admin` of the entity and read access to `company:member`.

```typescript
@ApplyAccessControlList(default_acl)
@Entity({ tableName: 'products' })
export class Product {
	@PrimaryKey({ type: 'text' })
	id!: string;

	@Unique({ name: 'products_name_key' })
	@Property({ type: 'text' })
	name!: string;
    // snippet //
}
```

Now lets add some hooks to the entity.  After we add all the available hooks to the Product entity, it should look something like this:

```typescript
@ApplyAccessControlList(default_acl)
@Entity({ tableName: 'products' })
export class Product {
	@PrimaryKey({ type: 'text' })
	id!: string;

	@Unique({ name: 'products_name_key' })
	@Property({ type: 'text' })
	name!: string;

	@Property({ type: 'datetime', length: 3 })
	createdAt!: Date;

	@Property({ type: 'datetime', length: 3 })
	updatedAt!: Date;

	@Property({ type: 'boolean', default: false })
	deleted = false;

	@ManyToOne({ entity: () => Organization, ref: true, index: 'products_organization_id_idx' })
	organization!: Ref<Organization>;

	@OneToMany({ entity: () => OrganizationAttribute, mappedBy: 'product' })
	organizationAttributes = new Collection<OrganizationAttribute>(this);

	@OneToMany({ entity: () => ProductMaterial, mappedBy: 'product' })
	productMaterials = new Collection<ProductMaterial>(this);

	@Hook(HookRegister.BEFORE_CREATE)
	async beforeCreate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return params;
	}
	@Hook(HookRegister.AFTER_CREATE)
	async afterCreate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return params;
	}
	@Hook(HookRegister.BEFORE_READ)
	async beforeRead(params: ReadHookParams<unknown, OrgContext>) {
		return params;
	}
	@Hook(HookRegister.AFTER_READ)
	async afterRead(params: ReadHookParams<unknown, OrgContext>) {
		return params;
	}
	@Hook(HookRegister.BEFORE_UPDATE)
	async beforeUpdate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return params;
	}
	@Hook(HookRegister.AFTER_UPDATE)
	async afterUpdate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return params
	}
	@Hook(HookRegister.BEFORE_DELETE)
	async beforeDelete(params: DeleteHookParams<unknown, OrgContext>) {
		return params;
	}
	@Hook(HookRegister.AFTER_DELETE)
	async afterDelete(params: DeleteHookParams<unknown, OrgContext>) {
		return params;
	}
}

```

These hooks don't actually do anything, but they are there to show you where you can add your own custom logic.  For example, you could add a hook to the `beforeCreate` method to add a default value to a field before it is created.  Or you could add a hook to the `beforeDelete` method to prevent a record from being deleted if it meets certain criteria.

While this is a nice feature and seems well implemented, storing this information in the entity means that anytime we sync the schema with what's in the database, we will lose this information.  To work around this, we have created a script that will reapply the ACLs to the entities and to generate a full complement of hooks for each entity that points to a generated sidecar file ('product-hooks.ts') after the schema is synced.  This allows you to store your hook logic in a separate file and not have to worry about losing them when you sync the schema.  

Now let's look at the product entity after this script has run:

```typescript
// other imports snipped for brevity //
import * as hooks from './product-hooks';

@ApplyAccessControlList(default_acl)
@Entity({ tableName: 'products' })
export class Product {
	@PrimaryKey({ type: 'text' })
	id!: string;

	@Unique({ name: 'products_name_key' })
	@Property({ type: 'text' })
	name!: string;

	@Property({ type: 'datetime', length: 3 })
	createdAt!: Date;

	@Property({ type: 'datetime', length: 3 })
	updatedAt!: Date;

	@Property({ type: 'boolean', default: false })
	deleted = false;

	@ManyToOne({ entity: () => Organization, ref: true, index: 'products_organization_id_idx' })
	organization!: Ref<Organization>;

	@OneToMany({ entity: () => OrganizationAttribute, mappedBy: 'product' })
	organizationAttributes = new Collection<OrganizationAttribute>(this);

	@OneToMany({ entity: () => ProductMaterial, mappedBy: 'product' })
	productMaterials = new Collection<ProductMaterial>(this);
	/**
 	** START GENERATED HOOKS SECTION
 	**/
	@Hook(HookRegister.BEFORE_CREATE)
	async beforeCreate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return hooks.beforeCreateHook(params);
	}
	@Hook(HookRegister.AFTER_CREATE)
	async afterCreate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return hooks.afterCreateHook(params);
	}
	@Hook(HookRegister.BEFORE_READ)
	async beforeRead(params: ReadHookParams<unknown, OrgContext>) {
		return hooks.beforeReadHook(params);
	}
	@Hook(HookRegister.AFTER_READ)
	async afterRead(params: ReadHookParams<unknown, OrgContext>) {
		return hooks.afterReadHook(params);
	}
	@Hook(HookRegister.BEFORE_UPDATE)
	async beforeUpdate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return hooks.beforeUpdateHook(params);
	}
	@Hook(HookRegister.AFTER_UPDATE)
	async afterUpdate(params: CreateOrUpdateHookParams<unknown, OrgContext>) {
		return hooks.afterUpdateHook(params);
	}
	@Hook(HookRegister.BEFORE_DELETE)
	async beforeDelete(params: DeleteHookParams<unknown, OrgContext>) {
		return hooks.beforeDeleteHook(params);
	}
	@Hook(HookRegister.AFTER_DELETE)
	async afterDelete(params: DeleteHookParams<unknown, OrgContext>) {
		return hooks.afterDeleteHook(params);
	}
	/**
 	** END GENERATED HOOKS SECTION
 	**/
}
```

Notice the slight change in the hook functions. They now point to a generated sidecar file that contains the actual hook logic.

```typescript
// product-hooks.ts Sidecar - Entity hooks for product
	import { CreateOrUpdateHookParams, ReadHookParams, DeleteHookParams } from '@exogee/graphweaver';

	import { OrgContext } from '../../acl_policies';
	import { ConsoleLogger } from '@nestjs/common';
	const logger = new ConsoleLogger('product-hooks')

	export const beforeCreateHook = (params: CreateOrUpdateHookParams<unknown, OrgContext>) => {
		logger.log('beforeCreateHook', { user: params.context.user, arguments: params.args });
		return params;
	}

		
	export const afterCreateHook = (params: CreateOrUpdateHookParams<unknown, OrgContext>) => {
		logger.log('afterCreateHook', { user: params.context.user, arguments: params.args });
		return params;
	}

		
	export const beforeReadHook = (params: ReadHookParams<unknown, OrgContext>) => {
		logger.log('beforeReadHook', { user: params.context.user, arguments: params.args });
		return params;
	}

		
	export const afterReadHook = (params: ReadHookParams<unknown, OrgContext>) => {
		logger.log('afterReadHook', { user: params.context.user, arguments: params.args });
		return params;
	}

		
	export const beforeUpdateHook = (params: CreateOrUpdateHookParams<unknown, OrgContext>) => {
		logger.log('beforeUpdateHook', { user: params.context.user, arguments: params.args });
		return params;
	}

		
	export const afterUpdateHook = (params: CreateOrUpdateHookParams<unknown, OrgContext>) => {
		logger.log('afterUpdateHook', { user: params.context.user, arguments: params.args });
		return params;
	}

		
	export const beforeDeleteHook = (params: DeleteHookParams<unknown, OrgContext>) => {
		logger.log('beforeDeleteHook', { user: params.context.user, arguments: params.args });
		return params;
	}

		
	export const afterDeleteHook = (params: DeleteHookParams<unknown, OrgContext>) => {
		logger.log('afterDeleteHook', { user: params.context.user, arguments: params.args });
		return params;
	}

	
```

You are free to store your hook logic in this file and not have to worry about losing them when you sync the schema.


To sync the schema with the database, run the following command:
```bash
pnpm sync
```

To control which ACLs get automatically applied to entities after the schema is synced, you can modify the `acl_utils/acl.ts` file.  This file contains a list of ACLs that will be applied to each entity.  

There are three string arrays: `publicEntities`, `ownerAndAdminEntities`, and `coldAdminEntities`.  Simply add the name of the postgres table that the entity represents to the appropriate array.  

A table name can only be applied to one array at a time as only one ACL can be applied to an entity.  If a table name is in multiple arrays, that entity will not have any ACL applied to it and an error message for that entity will appear in the console log .

For example, to add the entity `PolicyDefinition` to the `publicEntities` array, you would modify the file like so:
```typescript
export const publicEntities = [
  'policy_definitions',
  // Add more entities here
];
```

NOTE: Your Local Postgres will need to be running in order to sync the schema.  

To start the server, run the following command:

```bash
pnpm start
```

The server will start on `http://localhost:9001`.

The AdminUI will be available at `http://localhost:9000`.

To access the GraphQL Playground, navigate to `http://localhost:9000/playground`.
